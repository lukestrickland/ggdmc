# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @export
pnormP <- function(x, mean = 0, sd = 1, lt = TRUE, lg = FALSE) {
    .Call('_ggdmc_pnormP', PACKAGE = 'ggdmc', x, mean, sd, lt, lg)
}

#' @export
dnormP <- function(x, mean = 0, sd = 1, lg = FALSE) {
    .Call('_ggdmc_dnormP', PACKAGE = 'ggdmc', x, mean, sd, lg)
}

#' @rdname removet0
#' @export
remove_t0 <- function(rt, t0) {
    .Call('_ggdmc_remove_t0', PACKAGE = 'ggdmc', rt, t0)
}

#' @rdname makeR
#' @export
ttf <- function(drifts, A, b, t0, st0, nmean_v, n) {
    .Call('_ggdmc_ttf', PACKAGE = 'ggdmc', drifts, A, b, t0, st0, nmean_v, n)
}

#' @rdname makeR
#' @export
fptcdf <- function(rt, A, b, mean_v, sd_v, t0 = 0, posdrift = TRUE) {
    .Call('_ggdmc_fptcdf', PACKAGE = 'ggdmc', rt, A, b, mean_v, sd_v, t0, posdrift)
}

#' @rdname makeR
#' @export
fptpdf <- function(rt, A, b, mean_v, sd_v, t0 = 0, posdrift = TRUE) {
    .Call('_ggdmc_fptpdf', PACKAGE = 'ggdmc', rt, A, b, mean_v, sd_v, t0, posdrift)
}

#' @rdname makeR
#' @export
n1PDFfixedt0 <- function(rt, A, b, mean_v, sd_v, t0) {
    .Call('_ggdmc_n1PDFfixedt0', PACKAGE = 'ggdmc', rt, A, b, mean_v, sd_v, t0)
}

#' @rdname makeR
#' @export
n1PDFfixedt0_pda <- function(rt, A, b, mean_v, sd_v, t0, n, h, debug) {
    .Call('_ggdmc_n1PDFfixedt0_pda', PACKAGE = 'ggdmc', rt, A, b, mean_v, sd_v, t0, n, h, debug)
}

#' @rdname makeR
#' @export
make_r <- function(drifts, A, b, t0, st0, nmean_v, n, return_ttf, debug = FALSE) {
    .Call('_ggdmc_make_r', PACKAGE = 'ggdmc', drifts, A, b, t0, st0, nmean_v, n, return_ttf, debug)
}

#' @rdname makeR
#' @export
make_v <- function(n, mean_v, sd_v, posdrift = TRUE) {
    .Call('_ggdmc_make_v', PACKAGE = 'ggdmc', n, mean_v, sd_v, posdrift)
}

#' @rdname makeR
#' @export
rlba_norm <- function(n, A, b, mean_v, sd_v, t0, st0 = 0, posdrift = TRUE, return_ttf = FALSE, debug = FALSE) {
    .Call('_ggdmc_rlba_norm', PACKAGE = 'ggdmc', n, A, b, mean_v, sd_v, t0, st0, posdrift, return_ttf, debug)
}

#' Calculate Drift-diffusion Probability Density
#'
#' \code{g_minus} and \code{g_plus} implement A1 to A4 equations in Voss,
#' Rothermund, and Voss (2004). These equations calculate Ratcliff's
#' drift-diffusion model (1978). This source codes are derived from
#' Voss & Voss's fast-dm 30.2 in density.c.
#'
#' Two parallel functions \code{g_minus_parallel} and \code{g_plus_parallel},
#' using OpenMP libraries to do numerical integration. They resolve the
#' problem when high precision (> 10) is required.
#'
#' @param pVec a 9-element parameter (double) vector. The user has to follow
#' the sequence strictly. a, v, zr, d, sz, sv, t0, st0, RT, precision.
#' @references Voss, A., Rothermund, K., & Voss, J. (2004). Interpreting the
#' parameters of the diffusion model: A empirical validation
#' \emph{Memory and Cognition}, \bold{32(7)}, 1206--1220. \cr\cr
#' Ratcliff, R (1978). A theory of memory retrieval. \emph{Psychology Review},
#' \bold{85(2)}, 59--108.
#' @export
#' @examples
#' pvec1 <- c(a=2, v=2.5, zr=0.5, d=0, sz=0.3, sv=1, t0=0.3, st0=0,
#'            RT=.550, precision=2.5)
#' g_minus(pvec1) ## 0.04965882
#' g_plus(pvec1) ## 2.146265
#'
#' pvec2 <- c(a=2, v=2.5, zr=0.5, d=.2, sz=0.3, sv=1, t0=0.3, st0=.1,
#'            RT=.550, precision=2.5)
#'
#' g_minus(pvec2) ## 0.04194364
#' g_plus(pvec2)  ## 1.94957
#'
g_minus <- function(pVec) {
    .Call('_ggdmc_g_minus', PACKAGE = 'ggdmc', pVec)
}

#' @rdname g_minus
#' @export
g_plus <- function(pVec) {
    .Call('_ggdmc_g_plus', PACKAGE = 'ggdmc', pVec)
}

#' @export
n1PDF_gpu <- function(x, A, b, mean_v, sd_v, t0, n, nthread, gpuid, bw, debug) {
    .Call('_ggdmc_n1PDF_gpu', PACKAGE = 'ggdmc', x, A, b, mean_v, sd_v, t0, n, nthread, gpuid, bw, debug)
}

#' @export
n1PDF_plba0_gpu <- function(x, A, b, mean_v, sd_v, t0, mean_w, rD, swt, n, nthread, gpuid, bw, debug) {
    .Call('_ggdmc_n1PDF_plba0_gpu', PACKAGE = 'ggdmc', x, A, b, mean_v, sd_v, t0, mean_w, rD, swt, n, nthread, gpuid, bw, debug)
}

#' @export
n1PDF_plba1_gpu <- function(x, A, b, mean_v, sd_v, t0, mean_w, rD, swt, n, nthread, gpuid, bw, debug) {
    .Call('_ggdmc_n1PDF_plba1_gpu', PACKAGE = 'ggdmc', x, A, b, mean_v, sd_v, t0, mean_w, rD, swt, n, nthread, gpuid, bw, debug)
}

#' @export
FlipResponse_norm <- function(parmat, n1mat, dim1, dim3, parnames, cell) {
    .Call('_ggdmc_FlipResponse_norm', PACKAGE = 'ggdmc', parmat, n1mat, dim1, dim3, parnames, cell)
}

#' @export
checkddm2 <- function(pVec) {
    .Call('_ggdmc_checkddm2', PACKAGE = 'ggdmc', pVec)
}

p_df <- function(pVec, cell, pnames, allpar, parnames, model, type, dim1, dim2, dim3, isr1, n1idx, n1order = TRUE) {
    .Call('_ggdmc_p_df', PACKAGE = 'ggdmc', pVec, cell, pnames, allpar, parnames, model, type, dim1, dim2, dim3, isr1, n1idx, n1order)
}

#' @rdname density_rd
#' @export
getbounds <- function(data) {
    .Call('_ggdmc_getbounds', PACKAGE = 'ggdmc', data)
}

#' Compute Probability Density of Drift-Diffusion Model
#'
#' This function implements the equations in Voss, Rothermund, and Voss (2004).
#' These equations calculate Ratcliff's drift-diffusion model (RDM, 1978).
#' \code{ddmc} re-implements Voss, Rothermund, and Voss's (2004) equations A1
#' to A4 (page 1217) via Rcpp. This Rcpp function is akin to DMC's
#' \code{likelihood.dmc}. There is a \code{ddmc_parallel} with same arguments
#' using Open MPI to calculate RDM probability densities when data sets are
#' large (e.g., more than 5000 trials per condition) or when precision is set
#' high.
#'
#' @param x a data frame containing choices and RTs. This is akin to dnorm's x
#' argument.
#' @param pVec a parameter vector. For example,
#' p.vector <- c(a=1.25, v.f1=.20, v.f2=.33, z=.67, sz=.26, sv=.67, t0=.26)
#' @param precision a precision parameter. The larger, the higher precision to
#' estimate diffusion probability density. A general recommendation for the low
#' bound of precision is 2.5. If you need to use a precision higher than that,
#' you may want to consider using \code{ddmc_parallel}. A default value is set
#' at 2.5.
#' @param minLike a minimal log likelihood. If a estimated density is
#' less than minLike, the function returns minLike. A default value is set at
#' 1e-10.
#' @return a double vector with drift-diffusion probability density
#' @references Voss, A., Rothermund, K., & Voss, J. (2004).  Interpreting the
#' parameters of the diffusion model: An empirical validation.
#' \emph{Memory & Cognition}, \bold{32(7)}, 1206-1220. \cr\cr
#' Ratcliff, R. (1978). A theory of memory retrival. \emph{Psychological
#' Review}, \bold{85}, 238-255.
#' @examples
#' ## Set up a basic RDM design
#' model <- ggdmc:::model.dmc(
#' p.map=list(a="1", v="1", z="1", d="1", sz="1", sv="1", t0="1", st0="1"),
#'   constants=c(st0=0, d=0),
#'   match.map=list(M=list(s1="r1", s2="r2")),
#'   factors=list(S=c("s1", "s2")),
#'   responses=c("r1", "r2"),
#'   type="rd")
#'
#' pVec <- c(a=1, v=1, z=.5, sz=.25, sv=.2,t0=.15)
#'
#' ## data-model instance
#' dat <- ggdmc::simulate.model(model, pVec, 128)
#' dmi <- ggdmc::BindDataModel(dat, model)
#'
#' ## Print probability densities on the screen
#' density_rd(mdi, pVec)
#' ## [1]  0.674039828 0.194299671 0.377715949 1.056043402 0.427508806
#' ## [6]  2.876521367 0.289301835 2.701315781 0.419909813 1.890380685
#' ## [11] 2.736803321 1.278188278 0.607926999 0.024858130 1.878312335
#' ## [16] 0.826923114 0.189952016 1.758620294 1.696875882 2.191290074
#' ## [21] 2.666750382 ...
#'
#' mdi.large <- data.model.dmc(simulate(m1, nsim=1e4, p.vector=pVec), m1)
#'
#' ## system.time(den1 <- density_rd(mdi.large, pVec))
#' ##  user  system elapsed
#' ## 0.028   0.004   0.046
#'
#' ## system.time(den2 <- density_rd_omp(mdi.large, pVec))
#' ##  user  system elapsed
#' ## 0.200   0.000   0.023
#' ## all.equal(den1, den2)
#' ## [1] TRUE
#' @export
density_rd <- function(pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, precision = 2.5) {
    .Call('_ggdmc_density_rd', PACKAGE = 'ggdmc', pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, precision)
}

#' @rdname likelihood_norm
#' @export
density_norm <- function(pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1) {
    .Call('_ggdmc_density_norm', PACKAGE = 'ggdmc', pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1)
}

#' @rdname likelihood_norm
#' @export
density_norm_pda <- function(pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, nsim = 16384L, bw = .01, debug = FALSE) {
    .Call('_ggdmc_density_norm_pda', PACKAGE = 'ggdmc', pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, nsim, bw, debug)
}

#' @rdname likelihood_norm
#' @export
density_norm_gpu <- function(pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, nsim = 16384L, bw = .01, gpuid = 0L, nthread = 32L, debug = FALSE) {
    .Call('_ggdmc_density_norm_gpu', PACKAGE = 'ggdmc', pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, nsim, bw, gpuid, nthread, debug)
}

#' @rdname likelihood_norm
#' @export
density_plba1 <- function(pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, nsim = 16384L, bw = .01, ncore = 1L, debug = FALSE) {
    .Call('_ggdmc_density_plba1', PACKAGE = 'ggdmc', pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, nsim, bw, ncore, debug)
}

#' @rdname likelihood_norm
#' @export
density_plba0_gpu <- function(pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, nsim = 16384L, bw = .01, ncore = 1L, gpuid = 0L, nthread = 32L, debug = FALSE) {
    .Call('_ggdmc_density_plba0_gpu', PACKAGE = 'ggdmc', pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, nsim, bw, ncore, gpuid, nthread, debug)
}

#' @rdname likelihood_norm
#' @export
density_plba1_gpu <- function(pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, nsim = 16384L, bw = .01, ncore = 1L, gpuid = 0L, nthread = 32L, debug = FALSE) {
    .Call('_ggdmc_density_plba1_gpu', PACKAGE = 'ggdmc', pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, nsim, bw, ncore, gpuid, nthread, debug)
}

#' Calculate Summed, Log-likelihood of a Cognitive Model
#'
#' The function calculates logged likelihood for every trial and summs them
#' over.  The input data has to be a data frame carrying a model
#' specification, which is usually created by \code{model.data.dmc} function.
#'
#' @param pVec a parameter vector
#' @param pnames a string vector storing the name of a parameter vector
#' @param allpar all parameters
#' @param parnames parameter names
#' @param model a model specification
#' @param type model type
#' @param dim1 first dimension of a model
#' @param dim2 second dimension of a model
#' @param dim3 third dimension of a model
#' @param n1idx n1 order index
#' @param ise an index vector storing if a cell is empty.
#' @param cellidx cell index
#' @param RT a RT vector
#' @param matchcell an index vector storing is the cell is a match response
#' @param isr1 is r1 index
#' @param nsim number of simulation
#' @param bw bandwidth
#' @param ncore number of parallel core
#' @param gpupid GPU card index on a multiple GPU machine
#' @param debug whether to pring debugging information
#' @return a double scalar
#' @examples
#' m1 <- BuildModel(
#'   p.map     = list(a="1", v="1", z="1", d="1", sz="1", sv="1", t0="1", st0="1"),
#'   constants = c(st0=0, d=0),
#'   match.map = list(M=list(s1="r1", s2="r2")),
#'   factors   = list(S=c("s1", "s2")),
#'   responses = c("r1", "r2"),
#'   type      = "rd")
#'
#' pVec <- c(a=1, v=1, z=0.5, sz=0.25, sv=0.2,t0=.15)
#'
#' ## Set up a model-data instance
#' dat <- ggdmc::simulate.model(m1, pVec, 128)
#' mdi <- ggdmc::BindDataModel(dat, m1)
#' sumloglike(pVec, mdi)
#' ## [1] 0.3796048
#' @export
sumloglike <- function(pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, nsim, bw, ncore, gpuid, debug) {
    .Call('_ggdmc_sumloglike', PACKAGE = 'ggdmc', pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, nsim, bw, ncore, gpuid, debug)
}

#' @export
profile_rd <- function(pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, pname, ps) {
    .Call('_ggdmc_profile_rd', PACKAGE = 'ggdmc', pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, pname, ps)
}

#' @export
profile_norm <- function(pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, pname, ps) {
    .Call('_ggdmc_profile_norm', PACKAGE = 'ggdmc', pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, pname, ps)
}

#' @export
profile_norm_pda <- function(pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, pname, ps, nsim, bw) {
    .Call('_ggdmc_profile_norm_pda', PACKAGE = 'ggdmc', pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, pname, ps, nsim, bw)
}

#' @export
profile_norm_gpu <- function(pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, pname, ps, nsim, bw) {
    .Call('_ggdmc_profile_norm_gpu', PACKAGE = 'ggdmc', pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, pname, ps, nsim, bw)
}

#' @export
profile_plba1 <- function(pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, pname, ps, nsim, bw) {
    .Call('_ggdmc_profile_plba1', PACKAGE = 'ggdmc', pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, pname, ps, nsim, bw)
}

#' @export
profile_plba1_gpu <- function(pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, pname, ps, nsim, bw, gpuid, nthread, debug) {
    .Call('_ggdmc_profile_plba1_gpu', PACKAGE = 'ggdmc', pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, pname, ps, nsim, bw, gpuid, nthread, debug)
}

#' @export
profile_plba0_gpu <- function(pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, pname, ps, nsim, bw, gpuid, nthread, debug) {
    .Call('_ggdmc_profile_plba0_gpu', PACKAGE = 'ggdmc', pVec, pnames, allpar, parnames, model, type, dim1, dim2, dim3, n1idx, ise, cellidx, RT, matchcell, isr1, pname, ps, nsim, bw, gpuid, nthread, debug)
}

#' Extract Start Posterior Sample
#'
#' Extract the theta's of the first MCMC iteration across chains and
#' participants. Note that the ps array in DMC is a nchain x nsubject x
#' nparameter array. Armadillo operates on slice (the third dimension), so
#' chain dimension has to be on slice.
#'
#' @param samples a MCMC sample
#' @return a nsubject x npar x nchain array
#' @examples
#' m1 <- ggdmc::BuildModel(
#'   p.map     = list(a="1",v="1",z="1",d="1",sz="1",sv="1",t0="1",st0="1"),
#'   match.map = list(M=list(s1="r1", s2="r2")),
#'   factors   = list(S=c("s1", "s2")),
#'   constants = c(st0=0, d=0),
#'   responses = c("r1","r2"),
#'   type      = "rd")
#'
#' ## Population distribution
#' pop.prior <- ggdmc::BuildPrior(
#'       dists = rep("tnorm", 6),
#'       p1    = c(a=2,  v=2.5, z=.5, sz=.3, sv=1,  t0=.3),
#'       p2    = c(a=.5, v=.5,  z=.1, sz=.1, sv=.3, t0=.05),
#'       lower = c(0,-5, 0, 0, 0, 0),
#'       upper = c(5, 7, 2, 2, 2, 2))
#'
#' dat <- ggdmc139:::h.simulate.dmc(m1, ns=4, n=100, p.prior=pop.prior)
#' dmi <- ggdmc139:::data.model.dmc(dat, m1)
#' ps <- attr(dat, "parameters")
#'
#' p.prior  <- ggdmc::BuildPrior(
#'         dists = rep("tnorm", 6),
#'         p1    = c(a=2,  v=2.5, z=.5, sz=.3, sv=1,  t0=.3),
#'         p2    = c(a=.5, v=.5,  z=.1, sz=.1, sv=.3, t0=.05) * 5,
#'         lower = c(0,-5, 0, 0, 0, 0),
#'         upper = c(5, 7, 2, 2, 2, 2))
#'
#' ## Make a hyper-prior list
#' mu.prior <- ggdmc::BuildPrior(
#'         dists = rep("tnorm", 6),
#'         p1    = c(a=2,  v=2.5, z=.5, sz=.3, sv=1,  t0=.3),
#'         p2    = c(a=.5, v=.5,  z=.1, sz=.1, sv=.3, t0=.05) * 5,
#'         lower = c(0,-5, 0, 0, 0, 0),
#'         upper = c(5, 7, 2, 2, 2, 2))
#'
#' sigma.prior <- ggdmc::BuildPrior(
#'           dists = rep("beta", 6),
#'           p1    = c(a=1, v=1, z=1, sz=1, sv=1, t0=1),
#'           p2    = c(1,1,1,1,1,1),
#'           upper = c(2,2,2,2,2,2))
#'
#' pp.prior <- list(mu.prior, sigma.prior)
#'
#'
#' ## Random-effect model
#' ## hs0 <- ggdmc139:::h.samples.dmc(5e2, p.prior, dmi, pp.prior, thin=1)
#' ## hs0 <- ggdmc139:::h.run.dmc(hs0, 1, 1e2, p.migrate=.05, h.p.migrate=.05)
#' theta0 <- ggdmc:::GetTheta0(hs0)
#' @export
GetTheta0 <- function(samples) {
    .Call('_ggdmc_GetTheta0', PACKAGE = 'ggdmc', samples)
}

#' @export
sumloghprior <- function(location, scale, ldists, sdists, lp1, sp1, lp2, sp2, llower, slower, lupper, supper, llog, slog) {
    .Call('_ggdmc_sumloghprior', PACKAGE = 'ggdmc', location, scale, ldists, sdists, lp1, sp1, lp2, sp2, llower, slower, lupper, supper, llog, slog)
}

#' @export
sumloghlike <- function(thetak, dists, p1, p2, lower, upper, islog) {
    .Call('_ggdmc_sumloghlike', PACKAGE = 'ggdmc', thetak, dists, p1, p2, lower, upper, islog)
}

#' @export
StartIteration <- function(samples) {
    invisible(.Call('_ggdmc_StartIteration', PACKAGE = 'ggdmc', samples))
}

#' @export
init_new <- function(nmc, pprior, data, rp, thin, nchain, ncore = 1L, debug = FALSE) {
    .Call('_ggdmc_init_new', PACKAGE = 'ggdmc', nmc, pprior, data, rp, thin, nchain, ncore, debug)
}

#' @export
init_old <- function(nmc, samples, rp, thin) {
    .Call('_ggdmc_init_old', PACKAGE = 'ggdmc', nmc, samples, rp, thin)
}

#' @export
init_add <- function(nmc, samples, rp, thin) {
    .Call('_ggdmc_init_add', PACKAGE = 'ggdmc', nmc, samples, rp, thin)
}

#' @export
init_newnonhier <- function(nmc, data, pprior, rp, thin, nchain) {
    .Call('_ggdmc_init_newnonhier', PACKAGE = 'ggdmc', nmc, data, pprior, rp, thin, nchain)
}

#' @export
init_oldnonhier <- function(nmc, samples, rp, thin) {
    .Call('_ggdmc_init_oldnonhier', PACKAGE = 'ggdmc', nmc, samples, rp, thin)
}

#' @export
init_addnonhier <- function(nmc, samples, rp, thin) {
    .Call('_ggdmc_init_addnonhier', PACKAGE = 'ggdmc', nmc, samples, rp, thin)
}

#' @export
init_newhier <- function(nmc, data, pprior, ppprior, rp, thin, nchain) {
    .Call('_ggdmc_init_newhier', PACKAGE = 'ggdmc', nmc, data, pprior, ppprior, rp, thin, nchain)
}

#' @export
init_oldhier <- function(nmc, samples, rp, thin) {
    .Call('_ggdmc_init_oldhier', PACKAGE = 'ggdmc', nmc, samples, rp, thin)
}

#' @export
init_addhier <- function(nmc, samples, rp, thin) {
    .Call('_ggdmc_init_addhier', PACKAGE = 'ggdmc', nmc, samples, rp, thin)
}

#' Generate Random Choice-RT Data from LNR Model
#'
#' Race among \code{nacc} accumulators, using log-normal race model
#'
#' @param n numbers of observation
#' @param mean_log a n_acc length vector or a n_acc x n matrix. mean
#' of the distribution on the log scale without default value
#' @param sd_log a n_acc length vector or a n_acc x n matrix. Standard
#' deviation of the distribution on the log scale without default value.
#' @param t0 a scalar, a vector of length number of accumulators or a
#' matrix with 1 row per accumulator, when start time differ on each trial
#' @param st0 range of non-decision time variability, must be a scalar, as the same
#' variability is assumed in a common encoding/production stage
#' @return a matrix
#' @examples
#' ## A simple demo
#' pmat <- matrix(c(-1, 0, 1, 1, .2, .2, 0, 0), 2)
#' set.seed(123)
#' dat0 <- rlnr(4, pmat[,1], pmat[,2], pmat[,3], pmat[1,4])
#' ##           [,1] [,2]
#' ## [1,] 0.4100361    0
#' ## [2,] 0.4922407    0
#' ## [3,] 1.7855260    1
#' ## [4,] 0.4822220    1
#' ##
#' ## Three accumulators
#' n <- 1e5
#' meanlog <- c(.5, .75, 1);
#' sdlog <- c(1,1,1)
#' t0 <- c(.2,1,1)
#' set.seed(123)
#' dat1 <- rlnr(n, meanlog, sdlog, t0)
#' table(dat1[,2])
#' hist(dat1[,1], breaks = "fd")
#'
#' ## t0 has one element only
#' t0 <- .2
#' set.seed(123)
#' dat2 <- rlnr(n, meanlog, sdlog, t0)
#' table(dat2[,2])
#' hist(dat2[,1], breaks = "fd", freq = FALSE)
#' ## check t0 noise
#' st0 <- 1
#' set.seed(123)
#' dat3 <- rlnr(n, meanlog, sdlog, t0, st0)
#' table(dat3[,2])
#' hist(dat3[,1], breaks = "fd", freq = FALSE)
#'
#' ## Check matrix forms work (not yet)
#' dat4 <- rlnr(n, meanlog, sdlog, t0, st0)
#' sim <- data.frame(RT = dat4[,1], R = dat4[,2])
#' dns <- ggdmc:::plot.cell.density(sim,xlim=c(0,7),save.density=TRUE)
#' ichar <- as.character(1)
#'
#' meanlog <- matrix(rep(meanlog,length(dns[[ichar]]$x)),nrow=n_acc)
#' sdlog   <- matrix(rep(sdlog,  length(dns[[ichar]]$x)),nrow=n_acc)
#' t0      <- matrix(rep(t0, length.out=n_acc*length(dns[[ichar]]$x)), nrow=n_acc)
#'
#' ## Almost 8 times faster
#' library(rbenchmark)
#' res <- benchmark(r1 = rlnr(n, c(-1,0), c(1,1), c(.2, .2), 0),
#'                  r2 = ggdmc:::rlnrDF(n, c(-1,0), c(1,1), c(.2, .2), 0),
#'                  r3 = ggdmc:::rlnr(n, c(-1,0), c(1,1), c(.2, .2), 0),
#'                  replications = 1000)
#' print(res[,1:4])
#'
#' ## test replications elapsed relative
#' ##   r1         1000   1.695    7.995
#' ##   r2         1000   0.380    1.792
#' ##   r3         1000   0.212    1.000
#'
#' @export
rlnr <- function(n, meanlog, sdlog, t0, st0 = 0) {
    .Call('_ggdmc_rlnr', PACKAGE = 'ggdmc', n, meanlog, sdlog, t0, st0)
}

#' @export
rlnrDF <- function(n, meanlog, sdlog, t0, st0 = 0) {
    .Call('_ggdmc_rlnrDF', PACKAGE = 'ggdmc', n, meanlog, sdlog, t0, st0)
}

#' @export
n1PDFfixedt0_lnr1 <- function(x, meanlog, sdlog) {
    .Call('_ggdmc_n1PDFfixedt0_lnr1', PACKAGE = 'ggdmc', x, meanlog, sdlog)
}

#' @export
n1PDFfixedt0_lnr2 <- function(x, meanlog, sdlog) {
    .Call('_ggdmc_n1PDFfixedt0_lnr2', PACKAGE = 'ggdmc', x, meanlog, sdlog)
}

#' @export
spdf <- function(x, RT, n, h_in, debug = FALSE) {
    .Call('_ggdmc_spdf', PACKAGE = 'ggdmc', x, RT, n, h_in, debug)
}

#' @rdname rplba1R
#' @export
rplba0 <- function(n, A, b, t0, mean_v, mean_w, sd_v, rD, swt, ncore = 1L, debug = FALSE) {
    .Call('_ggdmc_rplba0', PACKAGE = 'ggdmc', n, A, b, t0, mean_v, mean_w, sd_v, rD, swt, ncore, debug)
}

#' @rdname rplba1R
#' @export
rplba1 <- function(n, A, b, t0, mean_v, mean_w, sd_v, rD, swt, ncore = 1L, debug = FALSE) {
    .Call('_ggdmc_rplba1', PACKAGE = 'ggdmc', n, A, b, t0, mean_v, mean_w, sd_v, rD, swt, ncore, debug)
}

#' @rdname rplba1R
#' @export
rplba1_test <- function(n, A, b, t0, mean_v, mean_w, sd_v, rD, swt, debug = FALSE) {
    .Call('_ggdmc_rplba1_test', PACKAGE = 'ggdmc', n, A, b, t0, mean_v, mean_w, sd_v, rD, swt, debug)
}

#' @rdname rplba1R
#' @export
rplba2 <- function(n, A, b, t0, mean_v, mean_w, sd_v, sd_w, rD, swt, ncore = 1L, debug = FALSE) {
    .Call('_ggdmc_rplba2', PACKAGE = 'ggdmc', n, A, b, t0, mean_v, mean_w, sd_v, sd_w, rD, swt, ncore, debug)
}

#' @rdname rplba1R
#' @export
rplba2_test <- function(n, A, b, t0, mean_v, mean_w, sd_v, sd_w, rD, swt, ncore = 1L, debug = FALSE) {
    .Call('_ggdmc_rplba2_test', PACKAGE = 'ggdmc', n, A, b, t0, mean_v, mean_w, sd_v, sd_w, rD, swt, ncore, debug)
}

#' @rdname rplba1R
#' @export
rplba3 <- function(n, A, B, C, mean_v, mean_w, sd_v, sd_w, rD, tD, swt, t0) {
    .Call('_ggdmc_rplba3', PACKAGE = 'ggdmc', n, A, B, C, mean_v, mean_w, sd_v, sd_w, rD, tD, swt, t0)
}

#' @rdname rplba1R
#' @export
n1PDF_plba1 <- function(x, A, b, mean_v, sd_v, t0, mean_w, rD, swt, n, h, ncore, debug) {
    .Call('_ggdmc_n1PDF_plba1', PACKAGE = 'ggdmc', x, A, b, mean_v, sd_v, t0, mean_w, rD, swt, n, h, ncore, debug)
}

#' @rdname rplba1R
#' @export
n1PDF_plba2 <- function(x, A, b, mean_v, sd_v, t0, mean_w, sd_w, rD, swt, n, h, ncore, debug) {
    .Call('_ggdmc_n1PDF_plba2', PACKAGE = 'ggdmc', x, A, b, mean_v, sd_v, t0, mean_w, sd_w, rD, swt, n, h, ncore, debug)
}

#' @rdname rplba1R
#' @export
n1PDF_plba3 <- function(x, n, A, B, C, mean_v, sd_v, mean_w, sd_w, rD, tD, swt, t0, h) {
    .Call('_ggdmc_n1PDF_plba3', PACKAGE = 'ggdmc', x, n, A, B, C, mean_v, sd_v, mean_w, sd_w, rD, tD, swt, t0, h)
}

#' Prior Probability Density
#'
#' \code{logprior} is a C++ function. It
#' matches five string types: \code{tnorm}, \code{beta_lu}, \code{gamma_l},
#' \code{lnorm_l}, and \code{constant} to determine which density functions to
#' call (via R API). For truncated normal density, \code{logprior} calls
#' \code{dtn_scalar} (internal dtnorm) to get probability densities from the
#' truncated normal distribution. Whether taking logarithm of the probability
#' density is determined by the boolean \code{log} sent in via
#' \code{prior.p.dmc}. By default, \code{prior.p.dmc} sets \code{log} to 1.
#'
#' @param p.vector the user's supplied parameter vector or a sampler supplied
#' theta/phi vector.
#' @param p.prior a list of list usually created by prior.p.dmc to store the
#' distributional setting for prior parameters.
#' @return a named double vector with probability densities for each model
#' parameter
#' @export
#' @examples
#' ## Use Drift-diffusion model as an example
#' prior1 <- BuildPrior(
#'   dists = c("tnorm", "tnorm", "beta", "tnorm", "beta", "beta"),
#'   p1    = c(a = 1, v = 0, z = 1, sz = 1, sv = 1, t0 = 1),
#'   p2    = c(a = 1, v = 2, z = 1, sz = 1, sv = 1, t0 = 1),
#'   lower = c(0,-5, NA, NA, 0, NA),
#'   upper = c(2, 5, NA, NA, 2, NA))
#'
#' ggdmc::view(prior1)
#' ##      mean sd lower upper log    dist  untrans
#' ##   a     1  1     0     2   1   tnorm identity
#' ##   v     0  2    -5     5   1   tnorm identity
#' ##   z     1  1     0     1   1 beta_lu identity
#' ##   sz    1  1  -Inf   Inf   1   tnorm identity
#' ##   sv    1  1     0     2   1 beta_lu identity
#' ##   t0    1  1     0     1   1 beta_lu identity
#'
#' dists = c("tnorm", "tnorm", "beta", "tnorm", "beta", "beta")
#' p1    = c(a = 1, v = 0, z = 1, sz = 1, sv = 1, t0 = 1)
#' p2    = c(a = 1, v = 2, z = 1, sz = 1, sv = 1, t0 = 1)
#' lower = c(0,-5, NA, NA, 0, NA)
#' upper = c(2, 5, NA, NA, 2, NA)
#' islog = rep(1, 6)
#' pVec1 <- c(a=1.15, v=-0.10, z=0.74, sz=1.23, sv=0.11, t0=0.87)
#' pnames <- names(pVec1)
#'
#' \dontrun{
#' setwd("~/Documents/DMC_10052017")
#' source ("dmc/dmc.R")
#' source ("dmc/dmc_myfunction.R")
#' source ("dmc/models/LBA/dists.R")
#' source ("dmc/models/LBA/lba_B.R")
#' }
#'
#' ggdmc::logprior(pVec1, prior1)
#' ggdmc::dprior(pVec1, names(pVec1), dists, p1,p2, lower, upper, islog)
#' \dontrun{ log.prior.dmc(pVec1, prior1) }
#' ##         a          v          z         sz         sv         t0
#' ##-0.5484734 -1.6008386  0.0000000 -0.9453885  0.0000000  0.0000000
#' summed.log.prior(pVec1, prior1)
#'
#'\dontrun{
#' res <- microbenchmark::microbenchmark(
#'   ggdmc::logprior(pVec1, prior1),
#'   ggdmc::dprior(pVec1, pnames, dists, p1,p2, lower, upper, islog),
#'   log.prior.dmc(pVec1, prior1), times = 1e3)
#' }
#'
#' ## Use LBA model as an example
#' prior2 <- ggdmc:::prior.p.dmc(
#'   dists = c("tnorm", "tnorm", "tnorm", "tnorm", "tnorm", "tnorm"),
#'   p1    = c(A=.4, B=.6, mean_v.true=1,  mean_v.false=0,  sd_v.true=.5, t0=.3),
#'   p2    = c(A=.1, B=.1, mean_v.true=.2, mean_v.false=.2, sd_v.true=.1, t0=.05),
#'   lower = c(0,   0, NA, NA, 0, .1),
#'   upper = c(NA, NA, NA, NA, NA, 1))
#'
#' pVec2 <- c(A=0.398, B=0.614, mean_v.true=1.040,
#'   mean_v.false=-0.032, sd_v.true=0.485, t0=0.271)
#'
#' dists = c("tnorm", "tnorm", "tnorm", "tnorm", "tnorm", "tnorm")
#' p1    = c(A=.4, B=.6, mean_v.true=1,  mean_v.false=0,  sd_v.true=.5, t0=.3)
#' p2    = c(A=.1, B=.1, mean_v.true=.2, mean_v.false=.2, sd_v.true=.1, t0=.05)
#' lower = c(0,   0, NA, NA, 0, .1)
#' upper = c(NA, NA, NA, NA, NA, 1)
#' islog = rep(1, 6)
#' pnames <- names(pVec2)
#'
#'
#' ggdmc::logprior(pVec2, prior2)
#' ggdmc::dprior(pVec2, pnames, dists, p1,p2, lower, upper, islog)
#' ##    A       B  mean_v.true  mean_v.false    sd_v.true      t0
#' ## 1.38    1.37         0.67          0.68         1.37    1.91
#' summed.log.prior(pVec2, prior2)
#'
#' \dontrun{
#' log.prior.dmc(pVec2, prior2)
#' res <- microbenchmark::microbenchmark(
#'   ggdmc::logprior(pVec2, prior2),
#'   ggdmc::dprior(pVec2, pnames, dists, p1,p2, lower, upper, islog),
#'   times = 1e3)
#' }
#' ## Unit: microseconds
#' ##                 expr     min      lq      mean   median      uq      max
#' ## ggdmc::logpriordmc    10.966  12.154  13.92842   13.132  15.646   28.776
#' ## ggdmc:::log.prior.dmc  9.081  10.617  12.28825   11.595  14.109   77.875
#' ## ggdmc::dprior         10.128  11.665  13.55588   12.712  15.226   71.170
#' ## log.prior.dmc         96.173 102.774 108.06765  105.533 107.628 2080.882
#' @export
dprior_ <- function(pvec, dists, p1, p2, lower, upper, islog) {
    .Call('_ggdmc_dprior_', PACKAGE = 'ggdmc', pvec, dists, p1, p2, lower, upper, islog)
}

#' @export
dpriorNV <- function(pvec, prior) {
    .Call('_ggdmc_dpriorNV', PACKAGE = 'ggdmc', pvec, prior)
}

#' @export
summedlogpriorNV <- function(pvec, prior) {
    .Call('_ggdmc_summedlogpriorNV', PACKAGE = 'ggdmc', pvec, prior)
}

#' @export
sumlogprior <- function(pvec, dists, p1, p2, lower, upper, islog) {
    .Call('_ggdmc_sumlogprior', PACKAGE = 'ggdmc', pvec, dists, p1, p2, lower, upper, islog)
}

#' @rdname rprior
#' @export
rprior_scalar <- function(prior) {
    .Call('_ggdmc_rprior_scalar', PACKAGE = 'ggdmc', prior)
}

#' @rdname rprior
#' @export
rprior_mat <- function(prior, n) {
    .Call('_ggdmc_rprior_mat', PACKAGE = 'ggdmc', prior, n)
}

#' @rdname rprior
#' @export
rprior_vec <- function(dists, p1, p2, lower, upper) {
    .Call('_ggdmc_rprior_vec', PACKAGE = 'ggdmc', dists, p1, p2, lower, upper)
}

#' Generate a Gamma Vector
#'
#' This is part of DE-MCMC algorithm. This function generates a gamma vector
#' for element-wise computation in Armadillo C++. This function is based on
#' p242 ter Braak (2006) who cited Roberts and Rosenthal (2001)
#'
#' @param npar number of parameters.
#' @param gammamult a tuning parameter stands for for gamma mutation. Default
#' value is 2.38.
#' @return a vector
#' @examples
#' pVec <- c(A = 1.51, b = 2.7, muv1 = 3.32, muv2 = 2.24, t_ND = 0.08,
#'           muw1 = 1.51, muw2 = 3.69, t_delay = 0.31, sv = 1, swt = 0.5)
#' gamma <- GetGamma(length(pVec), 2.38)
#' @export
GetGamma <- function(npar, gammamult = 2.38, hyper = FALSE) {
    .Call('_ggdmc_GetGamma', PACKAGE = 'ggdmc', npar, gammamult, hyper)
}

#' Draw n other chains and shuffle them
#'
#' This is part of DE-MCMC algorithm. \code{PickChains} draws \code{n}
#' chains out of \code{length(chains)} chains, excluding the kth chain.
#' \code{GetSubchains} is used in \code{migration} operator. It draws a subset
#' of chains in \code{nchain} chains.
#'
#' @param k the kth processed chain. Must be an integer within the range of 0
#' to \code{nchain - 1}. No check for errorly using R index.
#' @param n numbers of chain to draw.
#' @param chains an integer vector, indicating chain index, e.g., 0:23
#' @param nchain number of chains. Must be an integer.
#' @return a column vector
#' @keywords PickChains, getsubchains
#' @export
#' @examples
#' chains <- 0:23
#'
#' ## Presuming current processing chain is the 1st chain (C index = 0)
#' ## pick 2 chains out of 24 chains, excluding current chain.
#' PickChains(0, 2, chains)
#'
#' ## Example outputs
#' ##      [,1]
#' ## [1,]   17
#' ## [2,]   12
#' ##      [,1]
#' ## [1,]    2
#' ## [2,]    5
#' ##      [,1]
#' ## [1,]    5
#' ## [2,]    3
#' ##      [,1]
#' ## [1,]   10
#' ## [2,]    8
#' ##      [,1]
#' ## [1,]   15
#' ## [2,]    8
#'
#' ## get a random number of subchains
#' GetSubchains(nchain)
#' ##       [,1]
#' ##  [1,]    0
#' ##  [2,]    3
#' ##  [3,]    5
#' ##  [4,]    9
#' ##  [5,]   10
#' ##  [6,]   12
#' ##  [7,]   14
#' ##  [8,]   15
#' ##  [9,]   18
#' ## [10,]   20
#' ## [11,]   21
#' ## [12,]   22
#'
#' @rdname PickChains
#' @export
PickChains <- function(k, n, chains) {
    .Call('_ggdmc_PickChains', PACKAGE = 'ggdmc', k, n, chains)
}

#' @rdname PickChains
#' @export
GetSubchains <- function(nchain, debug = FALSE) {
    .Call('_ggdmc_GetSubchains', PACKAGE = 'ggdmc', nchain, debug)
}

#' @rdname PickChains
#' @export
SelectEmigrants <- function(ngroup, k) {
    .Call('_ggdmc_SelectEmigrants', PACKAGE = 'ggdmc', ngroup, k)
}

#' @export
run_dgmc <- function(samples, force, report, pm, qm, gammamult, ncore, ngroup) {
    .Call('_ggdmc_run_dgmc', PACKAGE = 'ggdmc', samples, force, report, pm, qm, gammamult, ncore, ngroup)
}

#' @export
run_dmc <- function(samples, force, report, pm, gammamult, ncore, debug = FALSE) {
    .Call('_ggdmc_run_dmc', PACKAGE = 'ggdmc', samples, force, report, pm, gammamult, ncore, debug)
}

#' @export
run_hyper_dmc <- function(samples, report, pm, hpm, gammamult, ncore, debug) {
    .Call('_ggdmc_run_hyper_dmc', PACKAGE = 'ggdmc', samples, report, pm, hpm, gammamult, ncore, debug)
}

#' @export
run_hyper_dgmc <- function(samples, report, pm, qm, gammamult, ngroup, ncore) {
    .Call('_ggdmc_run_hyper_dgmc', PACKAGE = 'ggdmc', samples, report, pm, qm, gammamult, ngroup, ncore)
}

rtn_scalar <- function(mean, sd, l, u) {
    .Call('_ggdmc_rtn_scalar', PACKAGE = 'ggdmc', mean, sd, l, u)
}

#' Truncated Normal Distribution
#'
#' Random number generation, probability density and cumulative density
#' functions for truncated normal distribution.
#'
#' @param x,q vector of quantiles;
#' @param n number of observations. n must be a scalar.
#' @param mean mean (must be scalar).
#' @param sd standard deviation (must be scalar).
#' @param lower lower truncation value (must be scalar).
#' @param upper upper truncation value (must be scalar).
#' @param lt lower tail. If TRUE (default) probabilities are \code{P[X <= x]},
#' otherwise, \code{P[X > x]}.
#' @param lp log probability. If TRUE (default is FALSE) probabilities p are
#' given as \code{log(p)}.
#' @return a column vector.
#' @examples
#' ## rtn example
#' dat1 <- rtnorm(1e5, 0, 1, 0, Inf)
#' ## dat2 <- msm::rtnorm(n, mean, sd, lower, upper)
#' ## den2 <- density(dat2)
#' hist(dat1, breaks="fd", freq=F)
#' ## lines(den2$x, den2$y, lwd=2.5)
#' ## res <- microbenchmark(
#' ##     rtn(n, mean, sd, lower, upper),
#' ##     msm::rtnorm(n, mean, sd, lower, upper))
#' ## print(res)
#'
#' ## dtn example
#' x <- seq(-5, 5, length.out=1e3)
#' dat1 <- dtnorm(x, 0, 1, -2, 2, 0)
#' ## dat2 <- msm::dtnorm(x, mean, sd, lower, upper, 0)
#' plot(x, dat1, type="l", lwd=2)
#' ## lines(x, dat2, lwd=2, lty="dashed", col="red")
#'
#' ## res <- microbenchmark(
#' ##     dtnorm(x, mean, sd, lower, upper, 0),
#' ##     msm::dtnorm(x, mean, sd, lower, upper, 0))
#' ## print(res)
#'
#' ## ptn example
#' x <- seq(-50, 10, length.out=1e3)
#' mean <- 0
#' sd <- 1
#' lower <- 0
#' upper <- 5
#' dat1 <- ptnorm(x, 0, 1, 0, 5, lp=TRUE)
#' ## dat2 <- msm::ptnorm(x, mean, sd, lower, upper, log.p=TRUE)
#' ## all(dat1[,1] == dat2)
#'
#' plot(x, log(dat1[,1]))
#' ## lines(x, log(dat2), col="red", lwd=2)
#' ## mtext("pnorm(x, log=TRUE)", adj = 0)
#' ## mtext("log(pnorm(x))", col = "red", adj = 1)
#' @export
dtnorm <- function(x, mean, sd, lower, upper, log = FALSE) {
    .Call('_ggdmc_dtnorm', PACKAGE = 'ggdmc', x, mean, sd, lower, upper, log)
}

#' @rdname dtnorm
#' @export
rtnorm <- function(n, mean, sd, lower, upper) {
    .Call('_ggdmc_rtnorm', PACKAGE = 'ggdmc', n, mean, sd, lower, upper)
}

#' @rdname dtnorm
#' @export
ptnorm <- function(q, mean, sd, lower, upper, lt = TRUE, lp = FALSE) {
    .Call('_ggdmc_ptnorm', PACKAGE = 'ggdmc', q, mean, sd, lower, upper, lt, lp)
}

#' Whether a hyper-prior distribution is set constant
#'
#' Check if a prior distribution for a location and scale parameter is set
#' constant. \code{testHyper} checks if the parameter names in location and
#' in scale match.
#'
#' @param ppList a pp.prior. First element is a location list and second
#' element is a scale list.
#' @return \code{isConstant} gives a npar x 2 matrix; \code{testHyper} gives
#' a SEXP vector
#' @examples
#' mu.prior <- ggdmc::BuildPrior(
#'         dists = rep("tnorm", 9),
#'         p1    = pop.mean,
#'         p2    = c(1,   1,  1,  1,   2,  2,  2, 2,  1),
#'         lower = c(0,   0,  0, .01, NA, NA, NA, NA, 0),
#'         upper = c(NA, NA, NA,  NA, NA, NA, NA, NA, NA))
#'
#' sigma.prior <- ggdmc::BuildPrior(
#'         dists = rep("beta", length(p.prior)),
#'         p1    = c(A = 1, B.r1 = 1, B.r2 = 1, t0 = 1,
#'                   mean_v.d1.true  = 1,
#'                   mean_v.d2.true  = 1,
#'                   mean_v.d1.false = 1,
#'                   mean_v.d2.false = 1,
#'                   sd_v.true = 1),
#'         p2    = rep(1, 9))
#' pp.prior <- list(mu.prior, sigma.prior)
#'
#' test1 <- GetConstIdx(pp.prior)
#' test2 <- lapply(pp.prior,function(x){
#'    lapply(x,function(y){attr(y,"dist")=="constant"})})
#'
#' @export
GetConstIdx <- function(ppprior) {
    .Call('_ggdmc_GetConstIdx', PACKAGE = 'ggdmc', ppprior)
}

#' @export
MatchPnames <- function(samples) {
    .Call('_ggdmc_MatchPnames', PACKAGE = 'ggdmc', samples)
}

#' @export
MatchPPPriorName <- function(ppprior) {
    .Call('_ggdmc_MatchPPPriorName', PACKAGE = 'ggdmc', ppprior)
}

#' @export
CheckPnames <- function(samples) {
    invisible(.Call('_ggdmc_CheckPnames', PACKAGE = 'ggdmc', samples))
}

#' @export
CheckHyperPnames <- function(samples) {
    invisible(.Call('_ggdmc_CheckHyperPnames', PACKAGE = 'ggdmc', samples))
}

#' Convert cell index list to a matrix
#'
#' Convert cell index list to a matrix. This is a convenient function.
#'
#' @param data a model data instance
#' @return a matrix
#'
#' @examples
#' m1 <- ggdmc::BuildModel(
#' p.map     = list(a="1",v="1",z="1",d="1",sz="1",sv="1",t0="1",st0="1"),
#'   match.map = list(M=list(s1="r1", s2="r2")),
#'   factors   = list(S=c("s1", "s2")),
#'   constants = c(st0=0, d=0),
#'   responses = c("r1","r2"),
#'   type      = "rd")
#'
#' ## Population distribution
#' p.prior <- ggdmc::BiuldPrior(
#'       dists = rep("tnorm", 6),
#'       p1    = c(a=2,  v=2.5, z=.5, sz=.3, sv=1,  t0=.3),
#'       p2    = c(a=.5, v=.5,  z=.1, sz=.1, sv=.3, t0=.05),
#'       lower = c(0,-5, 0, 0, 0, 0),
#'       upper = c(5, 7, 2, 2, 2, 2))
#'
#' dat <- ggdmc:::h.simulate.dmc(m1, ns=4, n=100, p.prior=p.prior)
#' dmi <- ggdmc:::data.model.dmc(dat, m1)
#'
#' cellIdx2Mat(dmi[[1]])
#'
#' @export
cellIdx2Mat <- function(data) {
    .Call('_ggdmc_cellIdx2Mat', PACKAGE = 'ggdmc', data)
}

