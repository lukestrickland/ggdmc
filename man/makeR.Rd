% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R, R/ggdmc_random.R
\name{ttf}
\alias{ttf}
\alias{fptcdf}
\alias{fptpdf}
\alias{n1PDFfixedt0}
\alias{n1PDFfixedt0_pda}
\alias{make_r}
\alias{make_v}
\alias{rlba_norm}
\alias{makeR}
\alias{make.r}
\title{Canonical Linear Ballistic Accumulation/Accumualtor Model}
\usage{
ttf(drifts, A, b, t0, st0, nmean_v, n)

fptcdf(rt, A, b, mean_v, sd_v, t0 = 0, posdrift = TRUE)

fptpdf(rt, A, b, mean_v, sd_v, t0 = 0, posdrift = TRUE)

n1PDFfixedt0(rt, A, b, mean_v, sd_v, t0)

n1PDFfixedt0_pda(rt, A, b, mean_v, sd_v, t0, n, h, debug)

make_r(drifts, A, b, t0, st0, nmean_v, n, return_ttf, debug = FALSE)

make_v(n, mean_v, sd_v, posdrift = TRUE)

rlba_norm(n, A, b, mean_v, sd_v, t0, st0 = 0, posdrift = TRUE,
  return_ttf = FALSE, debug = FALSE)

makeR(drifts, b, A, n_v, t0, st0 = 0, n, return.ttf = FALSE)

make.r(drifts, b, A, n_v, t0, st0 = 0, n, return.ttf = FALSE)
}
\arguments{
\item{drifts}{a n x n_v drift rate matrix. It can be a vector with 2 or more
elements. n is the numbers of observation. n_v is the numbers of
response/accumulator.}

\item{A}{start point upper bound, a vector of a scalar.}

\item{b}{decision threshold, a vector or a scalar.}

\item{t0}{nondecision time, a vector or a scalar.}

\item{st0}{nondecision time variation, a vector of a scalar. It is the upper
bound of a uniform distribution for t0 variability.}

\item{n}{numbers of observation/model simulations. This must be a scalar.}

\item{rt}{response times. A vector.}

\item{mean_v}{mean drift rate. Must be a n_acc-element vector}

\item{sd_v}{standard deviation of the drift rate. a scalar or a vector with
n_v elements.}

\item{posdrift}{a boolean switch indicating if trimming off negative drift
rates when drawing random drift rates.}

\item{h}{bandwidth. Only for PDA.}

\item{n_v}{numbers of response/accumulator, an integer. Note n_v must match
the length/size of \code{drifts} vector.}

\item{return.ttf}{a boolean switch indicating if return RTs for all
accumulators. When \code{return.ttf} is TRUE, a n_v x n ttf matrix is
returned.}
}
\value{
\code{make_r} gives either a time-to-finish (ttf) matrix or a n x 2
matrix, storing RTs (first column) and responses (second column). \code{n}
equals to number of model simulations. ttf is a n_v x n matrix with RTs from
all accumulators.
}
\description{
\code{makeR} stands for making/generating/simulating responses from
a LBA model. \code{make_r} and \code{make.r} use C++ function. These
make \code{r}, \code{_r}, \code{.r} functions are essentially \code{rLBA},
including \code{rlba_norm}. They uses a LBA model with parameters, b, A,
mean_v, sd_v and t0 (no st0) to generate choice RT random deviates.
}
\details{
\code{make_v} draws drift rate from normal or truncated normal distribution.
Each trial is stored as a row and each column is a drift rate for an
accumulator. You need to transpose drift rates generated by make_v for
\code{makeR}.

\code{make.r} is a wrapper function of \code{make_r}. You may
need to use ":::" to call make.r, because of S3 method naming convention. If
you call \code{make_r} directly, beware it returns C index and is only a
numeric matrix. It does not carry a string vector for the column names, RTs
and responses. See timing test to see why it might be a good idea not to
return it as a data frame. \code{rlbaCnorm} is R version of correlated LBA
model.

\code{rlba_norm} adds checks and calls \code{make_v} and \code{make_r}.
\code{rlba_norm} is only slightly quicker than \code{make_r}.

\code{n1PDFfixedt0} is defective density function for the fisrt node LBA
model. Defective means its probability does not normally normalize to 1.
Only the probabilities from all nodes/accumulators add to 1.
\code{n1PDFfixedt0} is equation (3) on  page 159 in Brown and
Heathcote (2008).  This equation assumes st0 is 0.

\code{fptcdf} and \code{fptpdf} are distribution and density functions with
four parameters A, b, v and sv, assuming t0 is zero. \code{fptcdf} and
\code{fptpdf} are respectively equation (1) and equation (2) on page 159 in
Brown and Heathcote (2008).
}
\examples{
## Basic test ----
mean_v <- matrix(c(2.4, 2.2)); mean_v
n <- 10
n_v <- 2
A <- 1.2
b <- 2.7
t0 <- .2
sd_v <- 1
st0 <- 0
posdrift <- TRUE
return.ttf <- FALSE

drifts <- ggdmc::make_v(n, A, b, t0, mean_v, sd_v, st0, posdrift)
dat0 <- ggdmc::make_r(drifts, b, A, n_v, t0, st0, n, return.ttf)
dat1 <- ggdmc:::make.r(drifts, b, A, n_v, t0, st0, n, return.ttf)
dat1 <- ggdmc::make_r(drifts, b, A, n_v, t0, st0, n, return.ttf)
dat1 <- ggdmc::makeR(t(drifts), b, A, n_v, t0, st0, n, return.ttf)
dat2 <- ggdmc::rlba_norm(n, A, b, t0, mean_v, sd_v, st0, posdrift, return.ttf)

## return time to finish ----
return.ttf <- TRUE
r1 <- ggdmc:::make.r(drifts, b, A, n_v, t0, st0, n, return.ttf)
r2 <- ggdmc::make_r(drifts, b, A, n_v, t0, st0, n, return.ttf)

## negative mean drift rates  ----
return.ttf <- FALSE
posdrift <- FALSE
mean_v <- matrix(c(2.4, -2.2)); mean_v
drifts <- ggdmc::make_v(n, A, b, t0, mean_v, sd_v, st0, posdrift)

## 3 accumulators ----
mean_v <- matrix(c(2.4, 2.3, 2.6)); mean_v
drifts <- ggdmc::make_v(n, A, b, t0, mean_v, sd_v, st0, posdrift)

posdrift <- TRUE
n_v <- 3
driftsR <- t(drifts)

r1 <- ggdmc:::make.r(drifts, b, A, n_v, t0, st0, n, return.ttf)
r2 <- ggdmc::makeR(driftsR, b, A, n_v, t0, st0, n, return.ttf)
r3 <- ggdmc::make_r(drifts, b, A, n_v, t0, st0, n, return.ttf)

## benchmark ----
\dontrun{
library(rbenchmark)
res <- benchmark(r1 = ggdmc::makeR(driftsR, b, A, n_v, t0, st0, n, return.ttf),
                 r2 = ggdmc:::make.r(drifts, b, A, n_v, t0, st0, n, return.ttf),
                 r3 = ggdmc::make_r(drifts, b, A, n_v, t0, st0, n, return.ttf),
                 replications = 100)
print(res[,1:4])
## test replications elapsed relative
##   r1          100   0.023     11.5  ## data.frame plus R overhead
##   r2          100   0.019      9.5  ## data.frame time
##   r3          100   0.002      1.0  ## optimal speed
}
## rlba_norm ----
p.vector  <- c(A= .75, B=.25, t0=.2, mean_v.true=2.5, mean_v.false= 1.5)
#'
n <- 2^10
mean_v <- matrix(c(2.5, 1.5)); mean_v
n_v <- 2
A <- .75
b <- 1
t0 <- .2
sd_v <- 1
st0 <- 0
posdrift <- TRUE
return.ttf <- FALSE

dat0 <- clba::rlba_norm(n, A, b, t0, mean_v, sd_v, st0, posdrift, return.ttf)
dat1 <- clba:::rlba.norm(n, A, b, t0, mean_v, sd_v, st0, posdrift, return.ttf)
head(dat0)
head(dat1)
ylba1 <- sort(dat0[dat0[,2] == 0, 1]) ## rt1
ylba2 <- sort(dat0[dat0[,2] == 1, 1]) ## rt2

\dontrun{
den0 <- rtdists::dLBA(dat0[, 1], dat0[, 2]+1, A=A, b=b, t0=t0, mean_v=mean_v[,1],
                      sd_v=rep(sd_v, 2))

df0 <- cbind(dat0, den0)
head(df0)
df1 <- df0[df0[,2]==0,]
df2 <- df0[df0[,2]==1,]
head(df1)
head(df2)
denlba1 <- df1[order(df1[,1]),3]
denlba2 <- df2[order(df2[,1]),3]
lbs <- 2
tks <- 1.5
par(mar = c(4, 5.3, 0.82, 1))
plot(ylba1, denlba1, type = "l", xlab="RT", ylab="Density", cex.lab=lbs,
     cex.axis=tks, lwd = 2, bty = "n")
lines(ylba2, denlba2, lwd=2)
text(0.6, 2.6, "Choice 1",  cex = tks)
text(.7, .8, "Choice 2",  cex = tks)
text(1.0, 2.0, "LBA Model", cex = tks, pos=4)
}

## make_v example
mean_v <- matrix(c(2.4, 2.2)); mean_v
n    <- 10
n_v  <- 2
A    <- 1.2
b    <- 2.7
t0   <- .2
sd_v <- 1
st0  <- 0
posdrift   <- TRUE
return.ttf <- FALSE
make_v(n, A, b, t0, mean_v, sd_v, st0, posdrift, return.ttf)
##          [,1]     [,2]
## [1,] 3.322569 3.579262
## [2,] 1.657905 1.181219
## [3,] 2.493664 1.093876
## ...

x <- seq(0, 5, .01)
head(rtdists:::n1PDFfixedt0)
head(ggdmc::n1PDFfixedt0)
den1 <- rtdists::n1PDF(x, A = .25, b = .6, mean_v = c(1, .25), sd_v = c(1, 2), t0 = .2, silent = TRUE)
den2 <- ggdmc::n1PDFfixedt0(x, A = .25, b = .6, mean_v = c(1, .25), sd_v = c(1, 2), t0 = .2)
den3 <- ggdmc::n1PDFfixedt0(x, A = rep(.25, 2), b = rep(.6, 2), mean_v = c(1, .25), sd_v = c(1, 2), t0 = rep(.2, 2))

all.equal(den1, den2[,1])
all.equal(den1, den3[,1])
## all TRUE

\dontrun{
require(rbenchmark)
res <- benchmark(r1 = rtdists::n1PDF(x, A = .25, b = .6, mean_v = c(1, .25), sd_v = c(1, 2), t0 = .2, silent = TRUE),
                 r2 = ggdmc::n1PDFfixedt0(x, A = .25, b = .6, mean_v = c(1, .25), sd_v = c(1, 2), t0 = .2),
                 r3 = ggdmc::n1PDFfixedt0(x, A = rep(.25, 2), b = rep(.6, 2), mean_v = c(1, .25), sd_v = c(1, 2), t0 = rep(.2, 2)),
                 replications = 100)

print(res[,1:4])
## test replications elapsed relative
##   r1          100   0.068    4.000
##   r2          100   0.017    1.000
##   r3          100   0.021    1.235
}

data <- seq(0, 3, length.out = 1e3);
den1 <- ggdmc::n1PDFfixedt0_pda(data, nsim=2^18, 1, .5, c(2.4, 1.6), c(1,1), .5,
      h_in = 0.001, k = .09, debug=T)
plot(data, den1, type="l")

######################
## n1PDFfixedt0_pda
######################
mean_v <- matrix(c(2.4, 2.2)); mean_v
n <- 2^14
n_v <- 2
A <- 1.2
b <- 2.7
t0 <- .2
sd_v <- c(1, 1)
h <- .01

x <- seq(0, 3, .001);
den1 <- ggdmc::n1PDFfixedt0_pda(x, A, b, mean_v, sd_v, t0, n, h)
den2 <- ggdmc::n1PDFfixedt0(x, A, b, mean_v, sd_v, t0)
den3 <- rtdists::n1PDF(x, A, b, mean_v = as.vector(mean_v), sd_v = sd_v, t0)
plot(x, den1, type="l")
lines(x, den2)
lines(x, den3, lwd= 3)

library(rbenchmark)
res <- benchmark(r1 = ggdmc::n1PDFfixedt0_pda(x, A, b, mean_v, sd_v, t0, n, h),
                 r2 = rtdists::n1PDF(x, A, b, mean_v = as.vector(mean_v), sd_v = sd_v, t0, silent = TRUE),
                 r3 = ggdmc::n1PDFfixedt0(x, A, b, mean_v, sd_v, t0),
                 replications = 100)
print(res[,1:4])

## test replications elapsed relative
##   r1          100   0.512    4.876
##   r2          100   0.257    2.448
##   r3          100   0.105    1.000

## SB's CDF R script
## fptcdf <- function(z,x0max,chi,v,sdv) {
##   if (x0max==0) return(pnorm(chi/z,mean=v,sd=sdv,lower.tail=F))
##   zs=z*sdv ; zu=z*v ; chiminuszu=chi-zu ; xx=chiminuszu-x0max
##   chizu=chiminuszu/zs ; chizumax=xx/zs
##   tmp1=zs*(dnorm(chizumax)-dnorm(chizu))
##   tmp2=xx*pnorm(chizumax)-chiminuszu*pnorm(chizu)
##   1+(tmp1+tmp2)/x0max
## }

dt   <- seq(.2, 2, by=0.05)          ## Decision times
pVec <- c(A=.5, b=1, v=2.4, sv=1)    ## parameter vector
Y    <- fptcdf(dt=dt, A=pVec[1], b=pVec[2], v=pVec[3], sv=pVec[4])

dt   <- seq(.1, 2, 0.01)           ## Decision times
pVec <- c(A=.5, b=1, v=2.4, sv=1)  ## parameter vector

Y1 <- fptcdf(z = dt, x0max = pVec[1], chi = pVec[2], v = pVec[3], sdv=pVec[4])
Y2 <- ggdmc:::fptcdf(rt = dt, A = pVec[1], b = pVec[2], mean_v = pVec[3], sd_v=pVec[4], t0 = 0, posdrift = FALSE)
Y3 <- rtdists:::plba_norm_core(dt, pVec[1], pVec[2], 0, pVec[3], pVec[4], FALSE, posdrift =  FALSE, length(dt))

all.equal(Y1, Y2[,1])
all.equal(Y3, Y2[,1])
all.equal(Y1, Y3)
## all TRUE

\dontrun{
## res <- benchmark(
##   r1 = fptcdf(z=dt, x0max=pVec[1], chi=pVec[2], v = pVec[3], sdv=pVec[4]),
##   r2 = ggdmc::fptcdf(rt=dt, A=pVec[1], b=pVec[2], mean_v = pVec[3], sd_v=pVec[4], 0),
##   r3 = rtdists:::plba_norm_core(dt, pVec[1], pVec[2], 0, pVec[3], pVec[4], TRUE, FALSE, length(dt)),
##   replications = 5e3)
## print(res[,1:4])

## test replications elapsed relative
## r1         5000   0.296    1.003
## r2         5000   0.295    1.000
## r3         5000   0.528    1.790
}

## SB's PDF R script
## fptpdf <- function(z,x0max,chi,v,sdv) {
## if (x0max==0) return( (chi/z^2)*dnorm(chi/z,mean=v,sd=sdv))
##   zs=z*sdv ; zu=z*v ; chiminuszu=chi-zu
##     chizu=chiminuszu/zs ; chizumax=(chiminuszu-x0max)/zs
##       (v*(pnorm(chizu)-pnorm(chizumax)) +
##         sdv*(dnorm(chizumax)-dnorm(chizu)))/x0max
## }

y1 <- fptpdf(z=dt, x0max=pVec[1], chi=pVec[2], v = pVec[3], sdv=pVec[4])
y2 <- ggdmc::fptpdf(rt=dt, A=pVec[1], b=pVec[2], mean_v = pVec[3], sd_v=pVec[4], t0 = 0, FALSE)
y3 <- rtdists:::dlba_norm_core(dt, pVec[1], pVec[2], 0, pVec[3], pVec[4], FALSE, FALSE, length(dt))

all.equal(y1, y2[,1])
all.equal(y3, y2[,1])
## all TRUE

\dontrun{
res <- benchmark(
     r1 = fptpdf(z=dt, x0max=pVec[1], chi=pVec[2], v = pVec[3], sdv=pVec[4]),
     r2 = ggdmc::fptpdf(rt=dt, A=pVec[1], b=pVec[2], mean_v = pVec[3], sd_v=pVec[4], 0),
     r3 = rtdists:::dlba_norm_core(dt, pVec[1], pVec[2], 0, pVec[3], pVec[4], TRUE, FALSE, length(dt)),
     replications = 5e3)
print(res[,1:4])

## test replications elapsed relative
##   r1         5000   0.296    1.138
##   r2         5000   0.260    1.000
##   r3         5000   0.510    1.962
}
}
