% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggdmc_sampling.R
\name{run}
\alias{run}
\alias{CheckConverged}
\alias{RunTillConverged}
\alias{StuckTests}
\alias{FlatTests}
\alias{MixTests}
\alias{LengthTests}
\alias{GetPLL}
\title{Run sampling}
\usage{
run(samples, report = 100, ncore = 1, pm = 0.05, qm = 0.01,
  gamma.mult = 2.38, ngroup = 3, force = FALSE, sampler = "DGMC")

CheckConverged(samples)

RunTillConverged(nmc, p.prior, data, thin, samples = NULL, report = 128,
  ncore = 1, p.migrate = 0, gamma.mult = 2.38, force = FALSE,
  effective.Size = 512, times = 8)

StuckTests(samples, verbose = FALSE, cut = 10)

FlatTests(samples, p1 = 1/3, p2 = 1/3, cut.location = 0.25,
  cut.scale = Inf, verbose = FALSE)

MixTests(samples, verbose = FALSE, cut = 1.01, split = TRUE)

LengthTests(samples, minN, nfun, verbose = FALSE)

GetPLL(fit, pars, start, end)
}
\arguments{
\item{samples}{a sample list generated by calling DMC's samples.dmc.}

\item{report}{how many iterations to return a report}

\item{gamma.mult}{a DEMC tuning parameter, affecting the size of jump}

\item{force}{Set force to FALSE for turning off force resampling. Set it
as an integer 1 to 10, forcing to resample a new parameter proposal every,
e.g., 1, 2, 3 step.}

\item{p.migrate}{set it greater than 0 to use migration samplers. For example
p.migrate=0.05 will use migration in 5\% chance.}

\item{cores}{a switch for computing the prob density for each trial in
parallel. Turn it on by setting any number > 1.}

\item{farjump}{No funciton for compatibility reason}
}
\value{
a DMC sample with class c("list", "dmc")
}
\description{
Run data-level Bayesian sampling.
}
\examples{
m1 <- model.dmc(
    p.map     = list(a="1",v="1",z="1",d="1",sz="1",sv="1", t0="1",st0="1"),
    constants = c(st0=0, d=0),
    match.map = list(M=list(s1="r1", s2="r2")),
    factors   = list(S=c("s1", "s2")),
    responses = c("r1", "r2"),
    type      = "rd")

## Use 6 prior truncated normal distributions
p.prior <- prior.p.dmc(
  dists = rep("tnorm", 6),
  p1    = c(a=2,  v=2.5, z=.5, sz=.3, sv=1,  t0=.3),
  p2    = c(a=.5, v=.5,  z=.1, sz=.1, sv=.3, t0=.05),
  lower = c(0,-5, 0, 0, 0, 0),
  upper = c(5, 7, 2, 2, 2, 2))

## parameter vector. These are the trun values simulating data
p.vector <- c(a=1,v=1, z=.5, sz=.25, sv=.2,t0=.15)
dat1 <- simulate(m1, p.vector, 128)
dmi1 <- BindDataModel(dat1, m1)

## Use DMC's plot_cell_density to examine distributions
## Accuracy around 70\%
par(mfrow=c(1,2))
ggdmc:::plot.cell.density(data.cell=dmi1[dmi1$S=="s1", ], C="r1", xlim=c(0,2))
ggdmc:::plot.cell.density(data.cell=dmi1[dmi1$S=="s2", ], C="r2", xlim=c(0,2))
par(mfrow=c(1,1))

## ---------------------------
## Profiles all 6 parameters
par(mfrow=c(2,3));
ggdmc:::profile.dmc("a",  .1,  2, p.vector, dmi1)
ggdmc:::profile.dmc("v",  .1,  2, p.vector, dmi1)
ggdmc:::profile.dmc("z",  .2, .8, p.vector, dmi1)
ggdmc:::profile.dmc("sz", .1, .9, p.vector, dmi1)
ggdmc:::profile.dmc("sv", .1,  2, p.vector, dmi1)
ggdmc:::profile.dmc("t0", .1,  .2, p.vector, dmi1)
par(mfrow=c(1,1));

## Initialse a DMC sample
## nthin == 1 (default)
## niter == 100
## prior distributions as listed in p.prior
## data  == model data instance 1
## do not use migrate sampler (default p.migrate=0)
m1 <- model.dmc(
  p.map     = list(a="1", v="1", z="1", d="1", sz="1", sv="1", t0="1", st0="1"),
  constants = c(st0=0, d=0),
  match.map = list(M = list(s1="r1", s2="r2")),
  factors   = list(S = c("s1", "s2")),
  responses = c("r1", "r2"),
  type      = "rd")

pvec1 <- c(a = 1, v = 1, z = .5, sz = .25, sv = .2,t0 = .15)
dat1  <- ggdmc:::simulate.model(m1, pvec1, 512)
dmi1  <- BindDataModel(dat1, m1)
prior1 <- prior.p.dmc(
  dists = rep("tnorm", 6),
  p1    = c(a=2,  v=2.5, z=.5, sz=.3, sv=1,  t0=.3),
  p2    = c(a=.5, v=.5,  z=.1, sz=.1, sv=.3, t0=.05),
  lower = c(0,-5, 0, 0, 0, 0),
  upper = c(5, 7, 2, 2, 2, 2))

## Because this will take around 20 to 40 s, set it NOT RUN.
##   user  system elapsed
## 17.552   0.004  17.551
\dontrun{
s0 <- ggdmc:::samples(512, prior1, dmi1)
s0 <- ggdmc:::run(s0, 32, 1, .05, 2.38, FALSE)
s1 <- ggdmc:::samples(512, prior1, samples = s0)
s1 <- ggdmc:::run(s1, 32, 1)

ggdmc:::plot.dmc(s0, pll.chain = TRUE)
ggdmc:::plot.dmc(s1, density   = TRUE)
ggdmc:::check.recovery.dmc(s1, pvec1)
}
}
