% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dmc_model.R
\name{p.df.dmc}
\alias{p.df.dmc}
\title{Get Response-Parameter Data Frame}
\usage{
p.df.dmc(p.vector, cell, model, n1order = TRUE)
}
\arguments{
\item{p.vector}{a parameter vector}

\item{cell}{a string or a integer indicating a design cell, e.g.,
\code{s1.f1.r1} or 1. Note the integer cannot exceed the number of cell.
use \code{length(dimnames(model))} to check the upper bound.}

\item{model}{a model, a cognitive model usually created by \code{model.dmc}}

\item{n1order}{a boolean switch to use node 1 ordering. This is only for
LBA model and its n1PDF likelihood function.}
}
\value{
each row corresponding to the model parameter for a response.
When \code{n1.order} is FALSE, p.df.dmc returns a martix in natural order,
which is used by \code{simulate.dmc}. By default \code{n1.order} is TRUE,
the returned matrix is usually used by n1PDF and \code{likelihood_norm}.
}
\description{
This is a wrapper function for C++ function, \code{pdfdmc}.
\code{p.df.dmc} extracts and arranges the values in a parameter vector,
which either is from a sampler or directly provided by the user, to a
response x parameter matrix. The matrix is usually used by a likelihood
function that picks a trial corresponding to its an experimental design cell
and calculates its probability density.
}
\examples{
model <- ggdmc:::model.dmc(
  p.map     = list(A = "1", B = "1", t0 = "1", mean_v = "M", sd_v = "1", st0 = "1"),
  match.map = list(M = list(s1 = 1, s2 = 2)),
  factors   = list(S = c("s1", "s2")),
  constants = c(st0 = 0, sd_v = 1),
  responses = c("r1", "r2"),
  type      = "norm")

p.vector <- c(A = .25, B = .35,  t0 = .2, mean_v.true = 1, mean_v.false = .25)
ggdmc:::print.cell.p(p.vector, model)

sim1 <- ggdmc:::simulate.model(model, p.vector, 1024)
data <- ggdmc:::BindDataModel(sim1, model)

model    <- attr(data, "model")
ise      <- attr(data, "cell.empty")
allpar   <- attr(model, "all.par")
parnames <- attr(model, "par.names")
type     <- attr(model, "type")
n1idx    <- attr(model, "n1.order")
mc       <- attr(model, "match.cell")
isr1     <- ggdmc:::check_rd(type, model)
cellidx  <- ggdmc:::cellidxmat(data)
pnames   <- names(p.vector)

for(i in dimnames(model)[[1]]) {
  tmp <- ggdmc::p_df(p.vector, i, pnames, allpar, parnames, model, type,
  dimnames(model)[[1]], dimnames(model)[[2]], dimnames(model)[[3]],
  isr1, n1idx, TRUE)
  cat(i, "\\n")
  print(tmp)
}

## Older note
m1 <- model.dmc(
  p.map     = list(a="1",v="F",z="1",d="1",sz="1",sv="F",t0="1",st0="1"),
  match.map = list(M=list(s1="r1", s2="r2")),
  factors   = list(S=c("s1","s2"), F=c("f1","f2")),
  constants = c(st0=0,d=0),
  responses = c("r1","r2"),
  type      = "rd")

m2 <- model.dmc(
  p.map = list(A = "1", B = "1", mean_v = "M", sd_v = "1",
  t0 = "1", st0 = "1"),
  constants = c(st0 = 0, sd_v = 1),
  match.map = list(M = list(s1 = 1, s2 = 2)),
  factors   = list(S = c("s1", "s2")),
  responses = c("r1", "r2"),
  type      = "norm")

pvec1 <- c(a=1.15, v.f1 = -0.10, v.f2 = 3, z=0.74, sz=1.23,
  sv.f1=0.11, sv.f2=0.21, t0=0.87)
pvec2 <- c(A = .75, B = .25, mean_v.true = 2.5, mean_v.false = 1.5,
  t0 = .2)

print.cell.p(pvec1, m1)
print.cell.p(pvec2, m2)

accMat1 <- ggdmc::p.df.dmc(pvec1, "s1.f1.r1", m1, FALSE)
accMat2 <- ggdmc::p.df.dmc(pvec2, "s1.r1",    m2, FALSE)

##    a    v   t0    z d   sz   sv st0
## 1.15 -0.1 0.87 0.26 0 1.23 0.11   0
## 1.15 -0.1 0.87 0.26 0 1.23 0.11   0

##    A b  t0 mean_v sd_v st0
## 0.75 1 0.2    2.5    1   0
## 0.75 1 0.2    1.5    1   0

\dontrun{
library(microbenchmark)
res <- microbenchmark(ggdmc::p.df.dmc(pvec2, "s1.r2", m2, FALSE),
 p.df.dmc(pvec2, "s1.r2", m2, FALSE),
 ggdmc::p_df(pvec2, "s1.r2", pnames, allpar, parnames, m2, type,
   dim1, dim2, dim3, isr1, n1, FALSE), times = 1e2)
res
}

## Unit: microseconds
##                        expr
## ggdmc::p.df.dmc(pvec2, ...)
## p.df.dmc(pvec2, ... )
## ggdmc::p_df(pvec2, ... )
##     min       lq      mean   median       uq     max neval cld
## 119.359 125.5400 132.10528 131.1270 138.2160 153.581   100   b
## 164.826 171.7745 178.52793 176.3145 180.4355 349.346   100   c
##  14.389  17.4265  24.17361  25.5630  28.7055  64.953   100   a

## Test internal function, p_df()
## cell <- 1
## n1order <- TRUE
## pnames   <- names(attr(model, "p.vector"))
## allpar   <- attr(model, "all.par")
## parnames <- attr(model, "par.names")
## type     <- attr(model, "type")
## n1       <- attr(model, "n1.order")
## resp     <- attr(model, "responses")
## dim1 <- dimnames(model)[[1]]
## dim2 <- dimnames(model)[[2]]
## dim3 <- dimnames(model)[[3]]
## if(type == "rd") { isr1 <- attr(model, "is.r1") } else { isr1 <- 0 }
## if(is.numeric(cell)) {
##   if ( cell > length(dim1) ) stop("cell out-of-range!")
##   cell <- dim1[cell]
## }

}
